/*ASSIGNMENT 2*/

/* 
 ___________________________
|                           |
|	SECTION ONE         |
|    	  OPTIONS           |
|___________________________|

*/

options { 
	  JAVA_UNICODE_ESCAPE = true;
	  IGNORE_CASE = true;
	  MULTI = true;
          VISITOR = true;
	}
/* 
 ___________________________
|                           |
|	SECTION TWO         |
|    	 USER-CODE          |
|___________________________|

*/
PARSER_BEGIN(MyParser)

	//required imports
	import java.io.*;
	import java.util.*;

	public class MyParser{

		public static Hashtable ST = new Hashtable(); 

		public static void main (String [] args) throws ParseException, FileNotFoundException { 
			String t1; 
			//STC t2;


			if ( args.length < 1){
				System.out.println("Cannot read from standard i/o....");
				System.out.println("Please input file name....");
				return;
			}else if (args.length == 1){
				try{
					MyParser tokeniser = new MyParser(new java.io.FileInputStream(args[0]));
					SimpleNode root = tokeniser.Prog(); //First node. Parse SS and store in "root".
					root.dump("");
					
				//	PrintVisitor pv = new PrintVisitor();
			        //	root.jjtAccept(pv, null);
					
				//	TypeCheckVisitor tc = new TypeCheckVisitor();
				//	root.jjtAccept(tc, ST); //Symbol table being used with type table
// TODO Suceess message here? 		System.out.println("Success.");

				} 
				catch (java.io.FileNotFoundException e) {
					System.err.println("File " + args[0] + " not found.");
					return;
				}
				catch(ParseException e) {
					System.out.println(e.getMessage());
					System.out.println("MyParser: Failure");
					System.out.println("MyParser: Encountered errors during parse");
				}
			}
		}
	}
PARSER_END(MyParser) 

/* 
 ___________________________
|                           |
|      SECTION THREE        |
|     TOKEN-DEFINITONS      |
|___________________________|

*/

TOKEN_MGR_DECLS: {
	static int commentNesting = 0;
}

SKIP : /* COMMENTS */ {
	"/*" { commentNesting++;
	       System.out.println("Comment"); } : IN_COMMENT
     | < SINGLE_COMMENT:  "//" (~["\n"])+ >  { System.out.println("One line comment found"); }
}

<IN_COMMENT> SKIP : {
	"/*" { commentNesting++; }
     |  "*/" { commentNesting--;
		if (commentNesting == 0){
			System.out.println("Comments closed");
			SwitchTo(DEFAULT);
		}
		else{
			System.out.println("Comments not shut yet");
			System.out.println("Comments left: " + Integer.toString(commentNesting));
		}
	     }
     | <~[]>
}

TOKEN : /*---RESERVED WORDS---*/ {
	< MAIN : "main" >
      | < BEGIN : "begin" >
      | < END : "end" >
      | < RETURN : "return" >
      | < IF : "if" >
      | < WHILE : "while" >
      | < ELSE : "else" >
      | < DECL_VARIABLE : "variable" >
      | < DECL_INTEGER : "integer" >
      | < DECL_CONSTANT : "constant" >
      | < VOID : "void" >
      | < IS : "is" >
      | < DO_SKIP : "skip" >
      | < IS_TRUE : "true" >
      | < IS_FALSE : "false" >
      | < BOOLEAN : "boolean" >
      /*| < : "" >*/
}

SKIP : /*** Ignoring spaces/tabs/newlines ***/
{
	" "
	| "\t"
	| "\n"
	| "\r"
	| "\f"
}

TOKEN : /*---TOKENS---*/ {	
	< COMMA : "," >
      | < SEMICOLUMN : ";" >	
      | < COLUMN : ":" >	
      | < IS_VALUE: ":=" >	
      | < OPEN_BRACKET : "(" >	
      | < CLOSE_BRACKET : ")" >	
      | < PLUS_SIGN : "+" >	
      | < MINUS_SIGN : "-" >	
      | < TILDA : "~" >	
      | < OR_SIGN : "|" >	
      | < AND_SIGN : "&" >	
      | < EQUALS_SIGN : "=" >	
      | < NEGATION_EQUALS : "!=" >	
      | < LESS_THAN: "<" >	
      | < EQUAL_LESS_THAN : "<=" >	
      | < GREATER_THAN : ">" >	
      | < EQUAL_GREATER_THAN: ">=" >	

}

TOKEN : /*---IDENTIFIERS---*/ {
        < INTEGER : "0" | ("-")? (["1" - "9"])(["0" - "9"])*>
	| < #DIGIT : ["0" - "9"] >
	| < ID : <LETTER>("_"|<LETTER>|<DIGIT>)*>
	| < #LETTER : ["a" - "z", "A" - "Z"] >
}
/* 
 ___________________________
|                           |
|	SECTION FOUR        |
|       GRAMMAR RULES       |
|___________________________|
*/
SimpleNode Prog() #Prog : {}
{
    DeclList()
    FuncList()
    Main() <EOF> {return jjtThis;}
}

void DeclList() : {}
{
    Decl() <SEMIC> DeclList()
  | {}
}

void Decl() : {}
{
    VarDecl()
  | ConstDecl()
}

void VarDecl() #VarDecl : {Token t; String id; String type;}
{
    t = <VAR> id = Identifier() <COLON> type = Type() { st.put(id, type, "var", scope); }
}

void ConstDecl() #ConstDecl : {Token t; String id; String type;}
{
    t = <CONST> id = Identifier() <COLON> type = Type() ConstAssign() { st.put(id, type, "const", scope); }
}

void ConstAssign() : {Token t;}
{
    t = <ASSIGN> Expr() {jjtThis.value = t.image;} #ConstAssign(>1)
}

void FuncList() : {}
{
    [Func() FuncList()]
}

void Func() #Func : {String id; String type;}
{
    type = Type() id = Identifier() {st.put(id, type, "function", scope); scope = id;} <LPAREN> ParamList() <RPAREN> <LBRACE>
    DeclList()
    StmBlk()
    <RETURN> <LPAREN> [Expr()] <RPAREN> <SEMIC> #FuncRet(>1)
    <RBRACE>
}

String Type() #Type : {Token t;}
{
  ( t = <INT> 
  | t = <BOOL>
  | t = <VOID>
  )
  { jjtThis.value = t.image; return t.image; }
}

void ParamList() #ParamList : {}
{
    NempParamList() NempParamListPrime()
  | {}
}

void NempParamList() #NempParamList : {String id; String type;}
{
    id = Identifier() <COLON> type = Type() { st.put(id, type, "function parameter", scope); }
}

void NempParamListPrime() : {}
{
    [<COMMA> NempParamList()]
}

void Main() #Main : {Token t;}
{
    {scope = "main";} t = <MAIN> <LBRACE> DeclList() StmBlk() <RBRACE>
}

void StmBlk() : {}
{
    Stm() StmBlk()
  | {}
}

void Stm() : {Token t;}
{
    (Identifier() ((t = <ASSIGN> Expr() <SEMIC> {jjtThis.value = t.image;}) | (<LPAREN> ArgList() <RPAREN> <SEMIC> {jjtThis.value = "procCall";}))) #Assign(2)
  | (<LBRACE> StmBlk() <LBRACE>)
  | (t = <IF> Cond() <LBRACE> StmBlk() <RBRACE> <ELSE> <LBRACE> StmBlk() <RBRACE> {jjtThis.value = t.image;}) #Stm
  | (t = <WHILE> Cond() <LBRACE> StmBlk() <RBRACE> {jjtThis.value = t.image;}) #Stm
  | (<SKP> <SEMIC>)
}

void Expr() : {}
{
    (Frag() Term())
  | (<LPAREN> Expr() <RPAREN> Term())
}

void Term() : {Token t;}
{
    t = <PLUS> Expr() {jjtThis.value = t.image;} #PlusOp(2)
  | t = <MINUS> Expr() {jjtThis.value = t.image;} #MinOp(2)
  | {}
}

void Frag() : {}
{
    (Identifier() [<LPAREN> ArgList() <RPAREN>])
  | (<MINUS> Identifier())
  | Num()
  | Bool()
}

void Num() #Num : {Token t;}
{
    t = <NUMBER> {jjtThis.value = t.image;}
}

void Bool() #Bool : {Token t;}
{
    (t = <TRUE> | t = <FALSE>) {jjtThis.value = t.image;}
}

void Cond() : {}
{
    (<NEGATE> Cond() CondPrime())
  | LOOKAHEAD(3) (<LPAREN> Cond() <RPAREN> CondPrime())
  | (Expr() CompOp() CondPrime())
}

void CondPrime() : {Token t;}
{
    t = <OR> Cond() {jjtThis.value = t.image;} #OrOp(2)
  | t = <AND> Cond() {jjtThis.value = t.image;} #AndOp(2) 
  | {}
}

void CompOp() : {Token t;}
{
    t = <EQ> Expr() {jjtThis.value = t.image;} #EqOp(2)
  | t = <NOT_EQ> Expr() {jjtThis.value = t.image;} #NotOp(2)
  | t = <LT> Expr() {jjtThis.value = t.image;} #LtOp(2)
  | t = <LT_EQ> Expr() {jjtThis.value = t.image;} #LtEqOp(2)
  | t = <GT> Expr() {jjtThis.value = t.image;} #GtOp(2)
  | t = <GT_EQ> Expr() {jjtThis.value = t.image;} #GtEqOp(2)
}

void ArgList() : {}
{
    [NempArgList()]
}

void NempArgList() : {}
{
    Identifier() [<COMMA> NempArgList()] #ArgList(>1)
}

String Identifier() #identifier : {Token t;}
{
    t = <ID> {jjtThis.value = t.image; return t.image;}
}
