/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. v1.jj */
/*@egen*//*ASSIGNMENT 2*/

/* 
 ___________________________
|                           |
|	SECTION ONE         |
|    	  OPTIONS           |
|___________________________|

*/

options { 
	  JAVA_UNICODE_ESCAPE = true;
	  IGNORE_CASE = true;
	               
                         
	}
/* 
 ___________________________
|                           |
|	SECTION TWO         |
|    	 USER-CODE          |
|___________________________|

*/
PARSER_BEGIN(MyParser)

	//required imports
	import java.io.*;
	import java.util.*;

	public class MyParser/*@bgen(jjtree)*/implements MyParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected static JJTMyParserState jjtree = new JJTMyParserState();

/*@egen*/

		public static Hashtable ST = new Hashtable(); 

		public static void main (String [] args) throws ParseException, FileNotFoundException { 
			String t1; 
			String t2;

			MyParser tokeniser;

			if ( args.length < 1){
				System.out.println("Cannot read from standard i/o....");
				System.out.println("Please input file name....");
				return;
			}else if (args.length == 1){
				try{
					tokeniser = new MyParser(new java.io.FileInputStream(args[0]));
					SimpleNode root = tokeniser.program(); //First node. Parse SS and store in "root".
					
					System.out.println("\nProgram: ");
					PrintVisitor pv = new PrintVisitor();
					root.jjtAccept(pv, null);
					
					System.out.println("\nType Checking");
					TypeCheckVisitor tc = new TypeCheckVisitor();
					root.jjtAccept(tc, ST); //Symbol table being used with type table
// TODO Suceess message here? 		System.out.println("Success.");

				} 
				catch (java.io.FileNotFoundException e) {
					System.err.println("File " + args[0] + " not found.");
					return;
				}
				catch(ParseException e) {
					System.out.println(e.getMessage());
					System.out.println("MyParser: Failure");
					System.out.println("MyParser: Encountered errors during parse");
				}
			}
		}
	}
PARSER_END(MyParser) 

/* 
 ___________________________
|                           |
|      SECTION THREE        |
|     TOKEN-DEFINITONS      |
|___________________________|

*/
TOKEN_MGR_DECLS: {
	static int commentNesting = 0;
}

SKIP : /* COMMENTS */ {
	"/*" { commentNesting++;
	       System.out.println("Comment"); } : IN_COMMENT
     | < SINGLE_COMMENT:  "//" (~["\n"])+ >  { System.out.println("One line comment found"); }
}

<IN_COMMENT> SKIP : {
	"/*" { commentNesting++; }
     |  "*/" { commentNesting--;
		if (commentNesting == 0){
			System.out.println("Comments closed");
			SwitchTo(DEFAULT);
		}
		else{
			System.out.println("Comments not shut yet");
			System.out.println("Comments left: " + Integer.toString(commentNesting));
		}
	     }
     | <~[]>
}

TOKEN : /*---RESERVED WORDS---*/ {
	< MAIN : "main" >
      | < BEGIN : "begin" >
      | < END : "end" >
      | < RETURN : "return" >
      | < IF : "if" >
      | < WHILE : "while" >
      | < ELSE : "else" >
      | < DECL_VARIABLE : "variable" >
      | < DECL_INTEGER : "integer" >
      | < DECL_CONSTANT : "constant" >
      | < VOID : "void" >
      | < IS : "is" >
      | < DO_SKIP : "skip" >
      | < IS_TRUE : "true" >
      | < IS_FALSE : "false" >
      | < BOOLEAN : "boolean" >
      /*| < : "" >*/
}

SKIP : /*** Ignoring spaces/tabs/newlines ***/
{
	" "
	| "\t"
	| "\n"
	| "\r"
	| "\f"
}

TOKEN : /*---TOKENS---*/ {	
	< COMMA : "," >
      | < SEMICOLUMN : ";" >	
      | < COLUMN : ":" >	
      | < IS_VALUE: ":=" >	
      | < OPEN_BRACKET : "(" >	
      | < CLOSE_BRACKET : ")" >	
      | < PLUS_SIGN : "+" >	
      | < MINUS_SIGN : "-" >	
      | < TILDA : "~" >	
      | < OR_SIGN : "|" >	
      | < AND_SIGN : "&" >	
      | < EQUALS_SIGN : "=" >	
      | < NEGATION_EQUALS : "!=" >	
      | < LESS_THAN: "<" >	
      | < EQUAL_LESS_THAN : "<=" >	
      | < GREATER_THAN : ">" >	
      | < EQUAL_GREATER_THAN: ">=" >	

}

TOKEN : /*---IDENTIFIERS---*/ {
        < INTEGER : "0" | ("-")? (["1" - "9"])(["0" - "9"])*>
	| < #DIGIT : ["0" - "9"] >
	| < ID : <LETTER>("_"|<LETTER>|<DIGIT>)*>
	| < #LETTER : ["a" - "z", "A" - "Z"] >
}
/* 
 ___________________________
|                           |
|	SECTION FOUR        |
|       GRAMMAR RULES       |
|___________________________|
*/

void Prog() : {/*@bgen(jjtree) Prog */
  ASTProg jjtn000 = new ASTProg(JJTPROG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Prog */
        try {
/*@egen*/
	decl_list() func_list() main() <EOF>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void decl_list() : {/*@bgen(jjtree) decl_list */
  ASTdecl_list jjtn000 = new ASTdecl_list(JJTDECL_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) decl_list */
        try {
/*@egen*/
	( decl() <SEMICOLUMN> decl_list())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void decl() : {/*@bgen(jjtree) decl */
  ASTdecl jjtn000 = new ASTdecl(JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) decl */
        try {
/*@egen*/
	var_decl() 
	| const_decl()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void var_decl(): {/*@bgen(jjtree) var_decl */
  ASTvar_decl jjtn000 = new ASTvar_decl(JJTVAR_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) var_decl */
        try {
/*@egen*/
	<DECL_VARIABLE> <ID> <COLUMN> type()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
	
void const_decl(): {/*@bgen(jjtree) const_decl */
  ASTconst_decl jjtn000 = new ASTconst_decl(JJTCONST_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) const_decl */
        try {
/*@egen*/
	<DECL_CONSTANT> <ID> <COLUMN> type() <IS_VALUE> expression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void type(): {/*@bgen(jjtree) type */
  ASTtype jjtn000 = new ASTtype(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) type */
        try {
/*@egen*/
	<DECL_INTEGER>
	| <BOOLEAN>
	| <VOID>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void func_list(): {/*@bgen(jjtree) func_list */
  ASTfunc_list jjtn000 = new ASTfunc_list(JJTFUNC_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) func_list */
        try {
/*@egen*/
	(function() func_list())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

void function(): {/*@bgen(jjtree) function */
  ASTfunction jjtn000 = new ASTfunction(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) function */
        try {
/*@egen*/
	type() <ID> <OPEN_BRACKET> parameter_list() <CLOSE_BRACKET> <IS> decl_list() <BEGIN> statement_block() <RETURN> <OPEN_BRACKET> (expression())? <CLOSE_BRACKET> <SEMICOLUMN><END>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}

void parameter_list(): {/*@bgen(jjtree) parameter_list */
  ASTparameter_list jjtn000 = new ASTparameter_list(JJTPARAMETER_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) parameter_list */
        try {
/*@egen*/
	(nemp_parameter_list())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void nemp_parameter_list(): {/*@bgen(jjtree) nemp_parameter_list */
  ASTnemp_parameter_list jjtn000 = new ASTnemp_parameter_list(JJTNEMP_PARAMETER_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) nemp_parameter_list */
        try {
/*@egen*/
	<ID> <COLUMN> type() (<COMMA> nemp_parameter_list())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void main() : {/*@bgen(jjtree) main */
  ASTmain jjtn000 = new ASTmain(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) main */
        try {
/*@egen*/
	<MAIN> <BEGIN> decl_list() statement_block() <END>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void statement_block(): {/*@bgen(jjtree) statement_block */
  ASTstatement_block jjtn000 = new ASTstatement_block(JJTSTATEMENT_BLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statement_block */
        try {
/*@egen*/
	( statement() statement_block() )?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void statement(): {/*@bgen(jjtree) statement */
  ASTstatement jjtn000 = new ASTstatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statement */
        try {
/*@egen*/
	<ID> ( <IS_VALUE> expression() | <OPEN_BRACKET> arg_list() <CLOSE_BRACKET> ) <SEMICOLUMN>
	| <BEGIN> statement_block() <END> 
	| <IF> condition() <BEGIN> statement_block() <END> 
	| <ELSE> <BEGIN> statement_block() <END> 
	| <WHILE> condition() <BEGIN> statement_block() <END> 
	| <DO_SKIP> <SEMICOLUMN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void expression(): {/*@bgen(jjtree) expression */
  ASTexpression jjtn000 = new ASTexpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) expression */
         try {
/*@egen*/
	 (
                (
                        <INTEGER> | <IS_TRUE> | <IS_FALSE>
                )
		
                (
                        binary_arith_op()
                        ((
                                (<MINUS_SIGN>)? <ID> (<OPEN_BRACKET> arg_list() <CLOSE_BRACKET>)?| <INTEGER> | <IS_TRUE> | <IS_FALSE>
                        )
			| <OPEN_BRACKET> expression() <CLOSE_BRACKET>)
                )*
        )
	|   (<MINUS_SIGN>)? <ID> ( 
		(//start OR 
			(
				<OPEN_BRACKET> arg_list() <CLOSE_BRACKET>
			) 
			| 
			( 
				<INTEGER> | <IS_TRUE> | <IS_FALSE> 
				)? 
				( binary_arith_op() 
					(( 
						(<MINUS_SIGN>)? <ID> (<OPEN_BRACKET> arg_list() <CLOSE_BRACKET>)? | <INTEGER> | <IS_TRUE> | <IS_FALSE> 
					) 
					| <OPEN_BRACKET> expression() <CLOSE_BRACKET>
					)
				)+ 
			) 
		 )? 
	| <OPEN_BRACKET> expression() <CLOSE_BRACKET>/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/ 
}

void binary_arith_op(): {/*@bgen(jjtree) binary_arith_op */
  ASTbinary_arith_op jjtn000 = new ASTbinary_arith_op(JJTBINARY_ARITH_OP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) binary_arith_op */
        try {
/*@egen*/
        <PLUS_SIGN> 
        | <MINUS_SIGN>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}    

void condition(): {/*@bgen(jjtree) condition */
  ASTcondition jjtn000 = new ASTcondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) condition */
        try {
/*@egen*/
        (
                (//begin OR 
                        <TILDA> condition()
                )
                |
                LOOKAHEAD(3)(
                        <OPEN_BRACKET> /*--going to cause conflict with expression last choice if no lookahead--*/ condition() <CLOSE_BRACKET>
                )
                |
                (
                        expression() comp_op() expression()
                ) //end OR
        )
        (
                LOOKAHEAD(2)( <OR_SIGN> | <AND_SIGN> ) //Issue is being caused here by recursive issue. Issue between [...]* and the tilda condition. It doesn't know whether to traverse back up the recusive tree or continue the [...]* if the next token is "|" //TODO TRY REMOVE 
                condition()
        )?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void comp_op(): {/*@bgen(jjtree) comp_op */
  ASTcomp_op jjtn000 = new ASTcomp_op(JJTCOMP_OP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) comp_op */
        try {
/*@egen*/
	<EQUALS_SIGN> 
	| <NEGATION_EQUALS> 
	| <LESS_THAN>
	| <EQUAL_LESS_THAN>
	| <GREATER_THAN>
	| <EQUAL_GREATER_THAN>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void arg_list(): {/*@bgen(jjtree) arg_list */
  ASTarg_list jjtn000 = new ASTarg_list(JJTARG_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) arg_list */
        try {
/*@egen*/
	(nemp_arg_list())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void nemp_arg_list(): {/*@bgen(jjtree) nemp_arg_list */
  ASTnemp_arg_list jjtn000 = new ASTnemp_arg_list(JJTNEMP_ARG_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) nemp_arg_list */
         try {
/*@egen*/
	 (<ID> (<COMMA> <ID>)* )/*@bgen(jjtree)*/
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/ 
}
